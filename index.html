<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¶ç²’å­åœ£è¯æ ‘â¤</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000; /* å…¨é»‘èƒŒæ™¯ */
            font-family: sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 5px #000;
        }
        
        /* ç¼©æ”¾æ§åˆ¶æŒ‰é’®å®¹å™¨ */
        #controls {
            position: fixed; 
            bottom: 20px; /* è·ç¦»åº•éƒ¨ 20px */
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            
            /* Flexbox å¸ƒå±€ç”¨äºå±…ä¸­å’Œé—´è· */
            display: flex;
            gap: 15px; 
            padding: 10px 20px; 
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
        }
        .control-btn {
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            /* å¢å¤§å°ºå¯¸ï¼Œæ–¹ä¾¿è§¦æ‘¸ */
            width: 50px; 
            height: 50px; 
            
            display: flex;
            align-items: center;
            justify-content: center;
            
            cursor: pointer;
            border-radius: 50%; /* åœ†å½¢æŒ‰é’® */
            font-size: 24px; /* å¢å¤§å›¾æ ‡å°ºå¯¸ */
            transition: background-color 0.3s, border-color 0.3s, transform 0.1s;
            margin: 0; 
        }
        .control-btn:hover {
            background-color: rgba(255, 255, 255, 0.4);
            border-color: white;
            transform: scale(1.05);
        }
        
        /* éŸ³ä¹æ§åˆ¶åŒºåŸŸ - å›ºå®šåœ¨å·¦ä¸‹è§’ */
        #music-area-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 11; /* ç¡®ä¿å®ƒåœ¨å…¶ä»–æ§ä»¶ä¹‹ä¸Š */
            display: flex; /* å¯ç”¨ Flexbox */
            align-items: center;
            gap: 10px; /* æŒ‰é’®å’Œè¿›åº¦æ¡ä¹‹é—´çš„é—´è· */
        }

        /* è¿›åº¦æ¡å®¹å™¨ */
        #audio-progress-bar-container {
            width: 150px; /* é•¿æ¡ */
            height: 8px; 
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
            /* ç¡®ä¿è¿›åº¦æ¡åœ¨å‚ç›´æ–¹å‘ä¸Šä¸æŒ‰é’®å±…ä¸­ */
            align-self: center; 
        }
        
        /* è¿›åº¦æ¡å¡«å…… */
        #audio-progress-bar-fill {
            height: 100%;
            width: 0%; /* åˆå§‹å®½åº¦ä¸º 0 */
            background-color: #ff69b4; /* ç²‰è‰² (Hot Pink) */
            transition: width 0.1s linear; /* å¹³æ»‘è¿‡æ¸¡ */
            border-radius: 4px;
        }

        /* æ¿€æ´»æ—¶çš„æ’­æ”¾çŠ¶æ€æŒ‡ç¤º */
        #musicPlayBtn.playing {
            background-color: rgba(60, 255, 60, 0.3); /* ç»¿è‰²æŒ‡ç¤º */
            border-color: #3cff3c;
        }

        canvas {
            display: block;
        }

        /* æ‰‹æœºç«¯ä¿¡æ¯æ–‡å­—é€‚é… */
        @media (max-width: 600px) {
            #info {
                font-size: 12px;
                top: 5px;
            }
            #controls {
                gap: 10px;
            }
            #music-area-container {
                bottom: 10px;
                left: 10px;
            }
            #audio-progress-bar-container {
                 width: 80px; /* æ‰‹æœºç«¯ç¨å¾®ç¼©çŸ­ */
            }
        }
    </style>
    
    <!-- å¼•å…¥ Font Awesome å›¾æ ‡åº“ -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <audio id="bgMusic" loop>
     <source src="./christmas.mp3" type="audio/mp3">
    </audio>

    <div id="info">æ‹–åŠ¨é¼ æ ‡æ—‹è½¬åœºæ™¯ â€¢ æ»šè½®ç¼©æ”¾</div>
    
    <!-- éŸ³ä¹æ§åˆ¶åŒºåŸŸ -->
    <div id="music-area-container">
        <!-- é»˜è®¤æ˜¾ç¤ºæ’­æ”¾å›¾æ ‡ -->
        <button id="musicPlayBtn" class="control-btn" aria-label="æ’­æ”¾/æš‚åœéŸ³ä¹">
            <i class="fas fa-play"></i>
        </button>
        <!-- éŸ³é¢‘è¿›åº¦æ¡ -->
        <div id="audio-progress-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
            <div id="audio-progress-bar-fill"></div>
        </div>
    </div>

    <!-- ç¼©æ”¾æ§åˆ¶æŒ‰é’® (å·²å¯¹è°ƒé¡ºåº) -->
    <div id="controls">
        <!-- æ”¾å¤§æŒ‰é’®ï¼šæ”¾åœ¨å·¦ä¾§ï¼Œæ›´ç¬¦åˆç›´è§‰ -->
        <button id="zoomInBtn" class="control-btn" aria-label="æ”¾å¤§"><i class="fas fa-plus"></i></button>
        <!-- ç¼©å°æŒ‰é’®ï¼šæ”¾åœ¨å³ä¾§ -->
        <button id="zoomOutBtn" class="control-btn" aria-label="ç¼©å°"><i class="fas fa-minus"></i></button>
    </div>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let particleTree, heartTopper, magicParticles, waveBase;
        let snowSystem, snowGeo;
        const clock = new THREE.Clock();
        
        let snowflakeTexture; 
        
        // æ ‘å¹²ç²’å­å’Œæ€»ç²’å­æ•°é‡
        const TOTAL_TREE_PARTICLES = 75000; 
        
        // æ ‘å¹²å°ºå¯¸å‚æ•° (ç”¨äºé¢œè‰²å’Œå½¢çŠ¶çš„æ¸å˜å‚è€ƒ)
        const VIRTUAL_TRUNK_HEIGHT = 8; 
        const VIRTUAL_TRUNK_RADIUS = 3; 
        
        // æ ‘çš„èµ·å§‹Yè½´ä½ç½®ï¼Œç”¨äºåº•éƒ¨ç•™å‡ºé—´éš™
        const TREE_BASE_Y = 10; 

        // Configuration Parameters
        const params = {
            snowCount: 3500,        
            magicCount: 350,        
            treeParticleCount: TOTAL_TREE_PARTICLES, 
            heartParticleCount: 10000,  
            waveParticleCount: 12000, 
            waveRadius: 90, 
            heartRotationSpeed: 0.015,
            TREE_HEIGHT: 50, // åœ£è¯æ ‘çš„é«˜åº¦
            HEART_SCALE: 4.5, // çˆ±å¿ƒæ¨¡å‹çš„ç¼©æ”¾æ¯”ä¾‹
            
            // æ ‘æœ¨å±‚çº§è°ƒæ•´: å‡å°‘åˆ†æ”¯æ•°é‡ï¼Œå±‚çº§æ›´å°‘ (ç°åœ¨ä¸»è¦é€šè¿‡å¹‚å‡½æ•°æ§åˆ¶å¯†åº¦)
            TREE_BRANCHES: 10, 
            
            // é­”åŠ›ç²’å­æ—‹è½¬åŠå¾„è°ƒæ•´ 
            MAGIC_BASE_RADIUS: 15, 
        };

        // --- ç²’å­è´´å›¾åˆ›å»º ---
        // ç”¨äºé›ªèŠ±çš„æ£±è§’è´´å›¾
        function createSnowflakeTexture() {
            if (snowflakeTexture) return snowflakeTexture; 

            const canvas = document.createElement('canvas');
            canvas.width = 64; 
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.translate(32, 32);

            // ç»˜åˆ¶ä¸€ä¸ªå¸¦æœ‰æ˜æ˜¾æ£±è§’çš„å…­è§’å½¢/é›ªèŠ±å½¢çŠ¶
            const numPoints = 6;
            const outerRadius = 30;
            const innerRadius = 10; 
            
            ctx.beginPath();
            for(let i = 0; i < numPoints * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i / (numPoints * 2)) * Math.PI * 2 + Math.PI / numPoints; 
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.fill();
            
            // å¢åŠ ä¸­å¿ƒå…‰æ–‘
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.shadowBlur = 4;
            ctx.shadowColor = 'white';
            ctx.fill();

            snowflakeTexture = new THREE.CanvasTexture(canvas);
            return snowflakeTexture;
        }

        // åˆ›å»ºåœ†å½¢å…‰æ–‘è´´å›¾ï¼ˆç”¨äºæ ‘å’Œçˆ±å¿ƒï¼‰
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; 
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.05, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            return new THREE.CanvasTexture(canvas);
        }

        // Initialize Scene
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); 

            // åˆå§‹æ’­æ”¾è§†è§’è°ƒæ•´
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 45, 120); 
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            renderer.sortObjects = false;

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            // è°ƒæ•´ç›®æ ‡ç‚¹ï¼Œä½¿æ ‘åº•é—´éš™å¯è§
            controls.target.set(0, TREE_BASE_Y + params.TREE_HEIGHT / 2, 0); 

            setupLighting(); 
            createWaveBase();
            createParticleTree(); 
            createHeartTopper();  
            createSnowSystem();
            createMagicDust();
            setupMusicControl(); // è®¾ç½®éŸ³ä¹æ§åˆ¶

            window.addEventListener('resize', onWindowResize, false);
            // æŒ‰é’®äº‹ä»¶ç›‘å¬ä¸éœ€è¦ä¿®æ”¹ï¼Œå› ä¸º ID æ²¡æœ‰å˜
            document.getElementById('zoomInBtn').addEventListener('click', () => adjustCameraZoom(5));
            document.getElementById('zoomOutBtn').addEventListener('click', () => adjustCameraZoom(-5));
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); 
            scene.add(ambientLight);
        }

        function adjustCameraZoom(delta) {
            camera.fov += delta;
            camera.fov = Math.max(10, Math.min(90, camera.fov)); 
            camera.updateProjectionMatrix();
        }

        // --- Circular Propagating Wave Particle Base ---
        function createWaveBase() {
            const waveGeo = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const initialRadius = []; 
            const color = new THREE.Color();
            
            const range = params.waveRadius; 

            for (let i = 0; i < params.waveParticleCount; i++) {
                const radius = Math.random() * range; 
                const angle = Math.random() * Math.PI * 2;
                
                const x = Math.cos(angle) * radius;
                // æ³¢æµªåŸºåº§ä¿æŒåœ¨ Y=0
                const z = Math.sin(angle) * radius;
                
                positions.push(x, 0, z); 
                initialRadius.push(radius);

                // äº”é¢œå…­è‰²çš„æ³¢æµªç²’å­
                const hue = Math.random(); 
                const saturation = 0.8; 
                const lightness = 0.6 + (Math.random() * 0.2); 
                
                color.setHSL(hue, saturation, lightness);
                colors.push(color.r, color.g, color.b);

                // è°ƒå¤§ç²’å­å¤§å°ï¼Œä½¿æ³¢çº¹æ›´æ˜æ˜¾
                sizes.push(Math.random() * 3.0 + 2.0); 
            }

            waveGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            waveGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            waveGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            waveGeo.userData = { initialRadius }; 

            const waveMat = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xffffff) },
                    pointTexture: { value: createParticleTexture() }, // ä½¿ç”¨åœ†å½¢å…‰æ–‘è´´å›¾
                    alphaTest: { value: 0.9 }
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        gl_PointSize = size * ( 150.0 / -mvPosition.z ); 
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4( color * vColor, 1.0 );
                        gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                        gl_FragColor.a *= 0.8; 
                        if (gl_FragColor.a < 0.05) discard; 
                    }
                `,
                blending: THREE.AdditiveBlending, 
                depthWrite: false,
                transparent: true,
                vertexColors: true 
            });

            waveBase = new THREE.Points(waveGeo, waveMat);
            scene.add(waveBase);
        }

        // --- Particle Christmas Tree ---
        function createParticleTree() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const initialOffsets = []; 
            const layerOffsets = []; 
            
            const originalPositions = [];
            geometry.userData = { originalPositions, initialOffsets, layerOffsets }; 

            const color = new THREE.Color();
            const treeHeight = params.TREE_HEIGHT; // 50
            const baseRadius = 25; 
            
            for (let i = 0; i < params.treeParticleCount; i++) {
                const isOrnament = Math.random() < 0.12; 
                
                // --- MODIFICATION: æ ‘é è¿‘åº•å±‚çš„ç²’å­è°ƒå¤šä¸€ç‚¹ (ä½¿ç”¨å¹‚å‡½æ•°åç½®) ---
                // 1.0 - Math.pow(Math.random(), 0.5) åå‘ 0 (åº•éƒ¨)
                const biasFactor = 1.0 - Math.pow(Math.random(), 0.5); 
                let y = biasFactor * treeHeight;
                
                // Add jitter and ensure non-negative
                y += (Math.random() - 0.5) * 1.0;
                y = Math.max(0, y); 
                // --- END MODIFICATION ---

                const t = 1 - (y / treeHeight); 
                
                // --- ç²’å­åŠå¾„å’Œå¹³æ»‘è¿‡æ¸¡ ---
                
                const foliageRadiusCalc = baseRadius * t * (0.3 + Math.random() * 0.7);
                const trunkRadiusCalc = VIRTUAL_TRUNK_RADIUS * (1 - y / VIRTUAL_TRUNK_HEIGHT * 0.5) * (0.5 + Math.random() * 0.5);

                let alphaRadius;
                if (y > VIRTUAL_TRUNK_HEIGHT) {
                    alphaRadius = 1.0;
                } else {
                    alphaRadius = y / VIRTUAL_TRUNK_HEIGHT;
                    alphaRadius = alphaRadius * alphaRadius; 
                }
                
                let currentRadius = trunkRadiusCalc + (foliageRadiusCalc - trunkRadiusCalc) * alphaRadius;

                const foliageSizeBase = Math.random() * 1.2 + 0.6;
                const trunkSizeBase = Math.random() * 1.8 + 1.2;
                sizes.push(trunkSizeBase + (foliageSizeBase - trunkSizeBase) * alphaRadius);


                let angle = (y * 5) + Math.random() * Math.PI * 2; 
                
                const r = Math.random() * currentRadius; 
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                // --- æ ‘çº¹ç†æ¨¡æ‹Ÿ ---
                const textureWaviness = Math.sin(y * 5 + angle * 3) * 0.2; 
                const noiseFactor = Math.random() * 0.5 + 0.5; 

                const finalX = x + textureWaviness * Math.cos(angle) * noiseFactor * 0.5;
                const finalZ = z + textureWaviness * Math.sin(angle) * noiseFactor * 0.5;
                const finalY = y + Math.sin(y * 30) * 0.05 * (1 - r / currentRadius); 
                
                // åº”ç”¨ TREE_BASE_Y åç§»ï¼Œä½¿æ ‘çš„åº•éƒ¨æŠ¬é«˜
                positions.push(finalX, finalY + TREE_BASE_Y, finalZ); 
                originalPositions.push(finalX, finalY + TREE_BASE_Y, finalZ);
                initialOffsets.push(Math.random() * Math.PI * 2);
                layerOffsets.push(Math.random() * Math.PI * 2); 

                
                if (isOrnament) {
                    // è£…é¥°ç‰©é¢œè‰²é€»è¾‘ä¸å˜
                    const isRed = Math.random() < 0.7;
                    if (isRed) {
                        color.setHSL(Math.random() * 0.05, 1.0, 0.8 + Math.random() * 0.1);
                    } else {
                        color.setHSL(0.14 + Math.random() * 0.05, 1.0, 0.7 + Math.random() * 0.2);
                    }
                    sizes[i] = Math.random() * 1.5 + 0.8; 
                } else {
                    // --- é¢œè‰²æ··åˆé€»è¾‘ (æ·±ç»¿è‰²æ ‘å¶) ---
                    let hue, saturation, lightness;

                    // æ ‘å¹²ç›®æ ‡é¢œè‰² (#4f1f0b -> H:0.044, S:0.75, L:0.18)
                    const H_TRUNK = 0.044 + Math.random() * 0.01; 
                    const S_TRUNK = 0.75 + Math.random() * 0.15; 
                    const L_TRUNK = 0.18 + Math.random() * 0.05;

                    // æ ‘å¶ç›®æ ‡é¢œè‰² (æ·±ç»¿è‰²)
                    const H_FOLIAGE = 0.33;
                    const S_FOLIAGE = 0.8;
                    const L_FOLIAGE_BASE = 0.22; // é¢œè‰²åŠ æ·±
                    const L_FOLIAGE_GRADIENT = (y - VIRTUAL_TRUNK_HEIGHT) / (treeHeight - VIRTUAL_TRUNK_HEIGHT) * 0.3;
                    const L_FOLIAGE = L_FOLIAGE_BASE + L_FOLIAGE_GRADIENT + (Math.random() * 0.05); 

                    if (y > VIRTUAL_TRUNK_HEIGHT) {
                        // æ ‘å¶éƒ¨åˆ†
                        hue = H_FOLIAGE; saturation = S_FOLIAGE; lightness = L_FOLIAGE;
                    } else {
                        // æ ‘å¹²åˆ°æ ‘å¶çš„è¿‡æ¸¡åŒº (0 <= y <= VIRTUAL_TRUNK_HEIGHT)
                        const alphaColor = y / VIRTUAL_TRUNK_HEIGHT; 

                        // çº¿æ€§æ··åˆé¢œè‰²
                        hue = H_TRUNK + (H_FOLIAGE - H_TRUNK) * alphaColor;
                        saturation = S_TRUNK + (S_FOLIAGE - S_TRUNK) * alphaColor;
                        lightness = L_TRUNK + (L_FOLIAGE - L_TRUNK) * alphaColor;
                    }
                    
                    color.setHSL(hue, saturation, lightness);
                }
                
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xffffff) },
                    pointTexture: { value: createParticleTexture() }, 
                    alphaTest: { value: 0.9 }
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        gl_PointSize = size * ( 150.0 / -mvPosition.z ); 
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4( color * vColor, 1.0 );
                        gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                        if (gl_FragColor.a < 0.1) discard; 
                    }
                `,
                blending: THREE.AdditiveBlending, 
                depthWrite: false,
                transparent: true,
                vertexColors: true 
            });

            particleTree = new THREE.Points(geometry, particleMaterial);
            scene.add(particleTree);
        }
        
        // --- Heart Topper ---
        function createHeartTopper() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            
            const originalPositions = [];
            geometry.userData = { originalPositions }; 

            const color = new THREE.Color();
            const heartScale = params.HEART_SCALE; 
            const treeHeight = params.TREE_HEIGHT; 
            
            // çˆ±å¿ƒå½¢çŠ¶åœ¨è‡ªèº«åæ ‡ç³»ä¸­çš„æœ€ä½ç‚¹ Y çº¦ä¸º -17
            const unscaledBottomTipY = -17; 
            
            // ç¼©æ”¾åï¼Œä»çˆ±å¿ƒä¸­å¿ƒåˆ°æœ€ä½ç‚¹çš„è·ç¦»
            const scaledBottomTipOffset = Math.abs(unscaledBottomTipY) / heartScale; 
            
            // çˆ±å¿ƒä¸­å¿ƒ Y åæ ‡ï¼šæ ‘é¡¶ (TREE_HEIGHT + TREE_BASE_Y) + åº•éƒ¨å°–ç«¯åç§»é‡ - 0.2 (å¾®å°çš„è¿æ¥é‡å )
            const heartY = (treeHeight + TREE_BASE_Y) + scaledBottomTipOffset - 0.2; 
            
            for (let i = 0; i < params.heartParticleCount; i++) {
                let x, y, z;
                
                const t = Math.random() * 2 * Math.PI - Math.PI; 
                const u = Math.random() * Math.PI; 

                x = 16 * Math.sin(t)**3 * Math.sin(u);
                y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * Math.sin(u);
                z = 16 * Math.sin(t)**3 * Math.cos(u) * 0.3; 

                x += (Math.random() - 0.5) * 0.3; 
                y += (Math.random() - 0.5) * 0.3;
                z += (Math.random() - 0.5) * 0.15;
                
                positions.push(x / heartScale, y / heartScale + heartY, z / heartScale);
                originalPositions.push(x / heartScale, y / heartScale + heartY, z / heartScale);

                const hue = 0.95 + Math.random() * 0.05; 
                const saturation = 1.0;
                const lightness = 0.6 + Math.random() * 0.15; 
                color.setHSL(hue, saturation, lightness);
                colors.push(color.r, color.g, color.b);

                sizes.push(Math.random() * 0.9 + 0.4); 
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const heartMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xffffff) },
                    pointTexture: { value: createParticleTexture() },
                    alphaTest: { value: 0.9 }
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        gl_PointSize = size * ( 150.0 / -mvPosition.z );
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4( color * vColor, 1.0 );
                        gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                        gl_FragColor.a *= 0.7; 
                        if (gl_FragColor.a < 0.1) discard; 
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                vertexColors: true 
            });

            heartTopper = new THREE.Points(geometry, heartMaterial);
            scene.add(heartTopper);
        }

        // --- Magic Particle System ---
        function createMagicDust() {
            const particleGeo = new THREE.BufferGeometry();
            const particleCount = params.magicCount;
            
            const positions = [];
            const speeds = []; 
            const radii = [];  
            const yOffsets = []; 
            
            for (let i = 0; i < particleCount; i++) {
                positions.push(0, 0, 0);
                
                speeds.push((Math.random() + 0.5) * 0.6); 
                // ç¯ç»•ç²’å­åŠå¾„
                radii.push(Math.random() * 7 + params.MAGIC_BASE_RADIUS); 
                yOffsets.push(Math.random() * 18); 
            }

            particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeo.userData = { speeds, radii, yOffsets };

            // ç¯ç»•ç²’å­ä½¿ç”¨é‡‘è‰²
            const particleMat = new THREE.PointsMaterial({
                color: 0xffd700, 
                size: 0.6, 
                transparent: true,
                opacity: 0.7, 
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: createParticleTexture()
            });

            magicParticles = new THREE.Points(particleGeo, particleMat);
            scene.add(magicParticles);
        }

        // --- Snow System ---
        function createSnowSystem() {
            snowGeo = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const sizes = []; 
            const snowRange = 90; 

            for (let i = 0; i < params.snowCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * snowRange, 
                    Math.random() * 60, 
                    (Math.random() - 0.5) * snowRange
                );
                velocities.push(
                    (Math.random() - 0.5) * 0.08, 
                    -(Math.random() * 0.15 + 0.08), 
                    (Math.random() - 0.5) * 0.08
                );
                
                // --- MODIFICATION: é›ªèŠ±ç²’å­è°ƒå¤§è°ƒå¤§è°ƒå¤§ ---
                sizes.push(Math.random() * 4.0 + 2.0); // èŒƒå›´ 2.0 åˆ° 6.0
                // --- END MODIFICATION ---
            }

            snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            snowGeo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
            snowGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1)); 

            const snowMat = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xffffff) },
                    pointTexture: { value: createSnowflakeTexture() }, // ä½¿ç”¨æ£±è§’è´´å›¾
                    alphaTest: { value: 0.9 }
                },
                vertexShader: `
                    attribute float size;
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        gl_PointSize = size * ( 150.0 / -mvPosition.z ); 
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform sampler2D pointTexture;
                    void main() {
                        gl_FragColor = vec4( color, 1.0 );
                        gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                        gl_FragColor.a *= 0.8; 
                        if (gl_FragColor.a < 0.1) discard; 
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
            });

            snowSystem = new THREE.Points(snowGeo, snowMat);
            scene.add(snowSystem);
        }
        
        // --- Music Control ---
        function setupMusicControl() {
            const music = document.getElementById('bgMusic');
            const playBtn = document.getElementById('musicPlayBtn');
            const icon = playBtn.querySelector('i');
            // è·å–æ–°çš„è¿›åº¦æ¡å…ƒç´ 
            const progressBarContainer = document.getElementById('audio-progress-bar-container');
            const progressBarFill = document.getElementById('audio-progress-bar-fill');
            
            let isPlaying = false; 

            music.volume = 0.5;

            // 1. ç›‘å¬éŸ³é¢‘æ—¶é—´æ›´æ–°ï¼Œä»¥æ›´æ–°è¿›åº¦æ¡
            music.addEventListener('timeupdate', () => {
                if (!isNaN(music.duration) && music.duration > 0) {
                    const percentage = (music.currentTime / music.duration) * 100;
                    progressBarFill.style.width = `${percentage}%`;
                    progressBarContainer.setAttribute('aria-valuenow', percentage.toFixed(0));
                }
            });

            // 2. ç›‘å¬è¿›åº¦æ¡ç‚¹å‡»ï¼Œå®ç°è·³è½¬æ’­æ”¾ (Seeking)
            progressBarContainer.addEventListener('click', (e) => {
                if (isNaN(music.duration) || music.duration === 0) return;
                
                // è®¡ç®—ç‚¹å‡»ç›¸å¯¹äºå®¹å™¨å·¦ä¾§çš„åç§»é‡
                const rect = progressBarContainer.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                
                // è®¡ç®—ç‚¹å‡»ä½ç½®å æ€»å®½åº¦çš„ç™¾åˆ†æ¯”
                const percentage = clickX / rect.width;
                
                // è®¾ç½®æ–°çš„æ’­æ”¾æ—¶é—´
                music.currentTime = music.duration * percentage;
            });

            // ç›‘å¬éŸ³é¢‘æ˜¯å¦å·²å‡†å¤‡å¥½æ’­æ”¾ï¼ˆè‡³å°‘åŠ è½½äº†å…ƒæ•°æ®ï¼‰
            music.addEventListener('loadedmetadata', () => {
                 console.log('Audio metadata loaded. Ready for user interaction.');
            });

            // ç›‘å¬é”™è¯¯äº‹ä»¶
            music.addEventListener('error', (e) => {
                let errorMessage = 'Unknown audio error.';
                // æ£€æŸ¥ mediaError å¯¹è±¡
                if (music.error) {
                    switch (music.error.code) {
                        case music.error.MEDIA_ERR_ABORTED:
                            errorMessage = 'Playback aborted by user.';
                            break;
                        case music.error.MEDIA_ERR_NETWORK:
                            errorMessage = 'Network error during download.';
                            break;
                        case music.error.MEDIA_ERR_DECODE:
                            errorMessage = 'Audio decoding error (unsupported format or corruption).';
                            break;
                        case music.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            errorMessage = 'Audio source not supported by the browser (codec/format issue).';
                            break;
                    }
                }
                console.error(`Audio Playback Error (${music.error ? music.error.code : 'N/A'}): ${errorMessage}. Please check the URL and file format.`, e);
                // ç¡®ä¿åœ¨å‡ºé”™æ—¶ï¼ŒçŠ¶æ€å’ŒUIéƒ½é‡ç½®ä¸ºæš‚åœ
                isPlaying = false;
                icon.className = 'fas fa-play';
                playBtn.classList.remove('playing');
            });
            
            // ä¿®æ­£åçš„ç‚¹å‡»äº‹ä»¶å¤„ç†ï¼Œä½¿ç”¨ isPlaying çŠ¶æ€é˜²æ­¢ç«æ€æ¡ä»¶
            playBtn.addEventListener('click', () => {
                if (isPlaying) {
                    // å¦‚æœæˆ‘ä»¬è®¤ä¸ºå®ƒæ­£åœ¨æ’­æ”¾ï¼Œåˆ™æ‰§è¡Œæš‚åœ
                    music.pause();
                    isPlaying = false;
                    icon.className = 'fas fa-pause';
                    playBtn.classList.remove('playing');
                } else {
                    // å¦‚æœæˆ‘ä»¬è®¤ä¸ºå®ƒå·²æš‚åœï¼Œåˆ™å°è¯•æ’­æ”¾
                    music.play().then(() => {
                        // æ’­æ”¾æˆåŠŸæ—¶æ‰æ›´æ–°çŠ¶æ€
                        isPlaying = true; 
                        icon.className = 'fas fa-pause';
                        playBtn.classList.add('playing');
                    }).catch(e => {
                        // æ’­æ”¾å¤±è´¥å¤„ç†ï¼ŒåŒ…æ‹¬è¢«ä¸­æ–­çš„é”™è¯¯ (AbortError)
                        if (e.name === 'AbortError') {
                             console.warn('Playback interrupted (often by a rapid second click). State remains paused.');
                        } else {
                            console.error('Failed to start playback after click. Check the console for more detailed Audio Errors.', e);
                        }
                        
                        // ç¡®ä¿çŠ¶æ€å’ŒUIåœ¨ä»»ä½•å¤±è´¥æƒ…å†µä¸‹éƒ½ä¿æŒæš‚åœ
                        isPlaying = false; 
                        icon.className = 'fas fa-play';
                        playBtn.classList.remove('playing');
                    });
                }
            });

            // åˆå§‹åŒ–å›¾æ ‡çŠ¶æ€ (é»˜è®¤æš‚åœ/æ’­æ”¾)
            if (music.paused) {
                icon.className = 'fas fa-play';
                playBtn.classList.remove('playing');
                isPlaying = false;
            } else {
                icon.className = 'fas fa-pause';
                playBtn.classList.add('playing');
                isPlaying = true;
            }
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            const treeHeight = params.TREE_HEIGHT; 
            const color = new THREE.Color();

            // 1. Particle Tree Sway & Pulse
            if (particleTree) {
                const positions = particleTree.geometry.attributes.position.array;
                const colors = particleTree.geometry.attributes.color.array;
                const originalPositions = particleTree.geometry.userData.originalPositions;
                const initialOffsets = particleTree.geometry.userData.initialOffsets;
                const totalParticles = originalPositions.length / 3;

                const windStrength = 0.3; 
                const windSpeed = 0.6; 
                
                const twinklePulse = Math.sin(time * 8) * 0.5 + 0.5; 

                for (let i = 0; i < totalParticles; i++) {
                    const i3 = i * 3;
                    
                    // originalY åŒ…å«äº† TREE_BASE_Y åç§»
                    const originalY = originalPositions[i3 + 1]; 
                    
                    // æ‘‡æ‘†å’Œè„‰å†²ä»ç„¶åªåŸºäºæ ‘çš„ç›¸å¯¹é«˜åº¦ (y - TREE_BASE_Y)
                    const treeRelativeY = originalY - TREE_BASE_Y;
                    
                    const originalX = originalPositions[i3];
                    const originalZ = originalPositions[i3 + 2];
                    
                    // å½’ä¸€åŒ– Y åæ ‡ (0 åˆ° 1)
                    const yNormalized = treeRelativeY / (treeHeight + VIRTUAL_TRUNK_HEIGHT); 
                    const swayAmplitude = windStrength * yNormalized; 

                    const swayX = Math.sin(time * windSpeed + initialOffsets[i] * 0.5) * swayAmplitude;
                    const swayZ = Math.cos(time * windSpeed + initialOffsets[i] * 0.5) * swayAmplitude * 0.5;
                    
                    const internalWaviness = Math.sin(time * 5.0 + originalX * 0.5 + originalZ * 0.5 + initialOffsets[i]) * 0.5 * (1.0 - yNormalized);
                    
                    positions[i3] = originalX + swayX + internalWaviness * Math.cos(initialOffsets[i]);
                    // Yè½´æ³¢åŠ¨ä¹ŸåŸºäºç›¸å¯¹é«˜åº¦
                    positions[i3 + 1] = originalY + Math.sin(time * 3 + initialOffsets[i]) * 0.1; 
                    positions[i3 + 2] = originalZ + swayZ + internalWaviness * Math.sin(initialOffsets[i]);
                    
                    
                    // è£…é¥°ç¯é—ªçƒé€»è¾‘ (ä¸å˜)
                    color.setRGB(colors[i3], colors[i3+1], colors[i3+2]);
                    
                    if (color.h < 0.2 || color.h > 0.95) { 
                        let h, s, l;
                        color.getHSL(color);
                        h = color.h;
                        s = color.s;
                        l = color.l;
                        
                        if (h > 0.9 || h < 0.05) { // çº¢è‰²è£…é¥°ç¯
                            l = Math.min(l * (1.0 + twinklePulse * 0.3), 1.0); 
                            
                            color.setHSL(h, s, l);
                            
                            colors[i3] = color.r;
                            colors[i3 + 1] = color.g;
                            colors[i3 + 2] = color.b;
                        }
                    }
                }
                particleTree.geometry.attributes.position.needsUpdate = true;
                particleTree.geometry.attributes.color.needsUpdate = true; 
                
                particleTree.rotation.y = time * 0.03; 
            }

            // 2. Heart Rotation 
            if (heartTopper) {
                heartTopper.rotation.y += params.heartRotationSpeed; 
                
                // é¢œè‰²é—ªçƒ
                const colorAttribute = heartTopper.geometry.attributes.color;
                const colors = colorAttribute.array;
                const lightnessBoost = 0.12 + Math.sin(time * 10) * 0.12; 
                for (let i = 0; i < colors.length / 3; i++) {
                    const h = 0.95;
                    const s = 1.0;
                    const l = 0.6 + lightnessBoost * (1 - (i % 10) / 10); 
                    color.setHSL(h, s, l);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                colorAttribute.needsUpdate = true;
            }
            
            // 3. Update Snow
            if (snowGeo) {
                const positions = snowGeo.attributes.position.array;
                const velocities = snowGeo.attributes.velocity.array;
                const snowRange = 90;

                for (let i = 0; i < params.snowCount; i++) {
                    const i3 = i * 3;
                    positions[i3] += velocities[i3] + Math.sin(time * 0.5 + positions[i3+1]) * 0.02;
                    positions[i3+1] += velocities[i3+1];
                    positions[i3+2] += velocities[i3+2] + Math.cos(time * 0.5 + positions[i3+1]) * 0.02;
                    
                    if (positions[i3+1] < 0) {
                        positions[i3+1] = 60; 
                        positions[i3] = (Math.random() - 0.5) * snowRange;
                        positions[i3+2] = (Math.random() - 0.5) * snowRange;
                    }
                }
                snowGeo.attributes.position.needsUpdate = true;
            }

            // 4. Update Magic Particles 
            if (magicParticles) {
                const positions = magicParticles.geometry.attributes.position.array;
                const { speeds, radii, yOffsets } = magicParticles.geometry.userData;
                
                const rotationSpeedFactor = 0.5; // å‡æ…¢æ—‹è½¬é€Ÿåº¦
                
                for (let i = 0; i < params.magicCount; i++) {
                    const i3 = i * 3;
                    const angle = time * speeds[i] * rotationSpeedFactor + i; 
                    
                    // ç²’å­åœ¨ Y=0 åˆ° Y=20 ä¹‹é—´å¾ªç¯ï¼Œæ‰€ä»¥åŠå¾„åœ¨ä¸Šå‡è¿‡ç¨‹ä¸­ä¸ä¼šè¡°å‡
                    const radius = radii[i]; 
                    
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    // ç²’å­ç»•æ ‘åº•ä¸Šå‡å’Œèºæ—‹ (Y è½´å¾ªç¯é«˜åº¦ä¸å˜ï¼Œä½†èµ·å§‹ç‚¹åœ¨ TREE_BASE_Y)
                    positions[i3] = x;
                    positions[i3 + 1] = (yOffsets[i] + time * speeds[i] * 1.5) % (treeHeight * 0.8) + TREE_BASE_Y; 
                    positions[i3 + 2] = z;
                }
                magicParticles.geometry.attributes.position.needsUpdate = true;
            }

            // 5. Update Wave Base (åœ†å½¢ä¼ æ’­æ³¢çº¹)
            if (waveBase) {
                const positions = waveBase.geometry.attributes.position.array;
                const initialRadius = waveBase.geometry.userData.initialRadius;
                const totalParticles = initialRadius.length;
                const speed = 0.5;
                const waveLength = 0.15; 
                const amplitude = 3.0; 

                for (let i = 0; i < totalParticles; i++) {
                    const i3 = i * 3;
                    const r = initialRadius[i];
                    
                    const waveFactor = Math.sin((r * waveLength - time * speed) * Math.PI) * amplitude;
                    
                    // æ³¢æµªåŸºåº§ä¿æŒåœ¨ Y=0
                    positions[i3 + 1] = waveFactor * Math.exp(-0.01 * r); 
                }
                waveBase.geometry.attributes.position.needsUpdate = true;
            }
            
            // Final render and control update
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Initialize on load ---
        window.onload = function () {
            init();
            animate(); 
        }
    </script>
</body>
</html>
